{
  "master": {
    "tasks": [
      {
        "id": 46,
        "title": "Register `pk agent` Command with CLI",
        "description": "Register the `agent` command and its subcommands (`start browser`, `stop browser`) with the Commander.js CLI structure to make them accessible to users.",
        "details": "Modify the main CLI command registration file (e.g., `packages/cli/src/commands/index.ts`) to include the `agent` command. In `packages/cli/src/commands/agent.ts`, define the `start` and `stop` subcommands, each accepting an `<agent_type>` argument, which will be 'browser'. Ensure help text is automatically generated and descriptive.",
        "testStrategy": "Run `pk --help` and verify the `agent` command is listed. Run `pk agent --help` and verify `start` and `stop` subcommands are listed. Execute `pk agent start browser` and `pk agent stop browser` to ensure the command structure is wired up, even if the underlying logic is not yet implemented. Check for proper command recognition and argument parsing.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze existing CLI command registration structure",
            "description": "Examine the current Commander.js setup in packages/cli/src/commands/index.ts to understand how commands are registered and exported, and review existing command patterns for consistency.",
            "dependencies": [],
            "details": "Study the existing command registration patterns, import/export structure, and how other commands like 'config' are implemented. Identify the exact location where new commands should be added and understand the naming conventions used.\n<info added on 2025-07-28T03:19:42.076Z>\nAnalysis completed - CLI architecture fully understood. The agent command is already properly registered and integrated. Key findings: packages/cli/src/gemini.tsx uses direct import routing (lines 101-197), commands/index.ts exports handlers correctly, and agent.ts already exists with proper integration. No new registration needed - only need to enhance existing agent.ts functionality for additional agent types beyond browser-only support.\n</info added on 2025-07-28T03:19:42.076Z>",
            "status": "cancelled",
            "testStrategy": "Review the current CLI help output with 'pk --help' to see existing command structure and examine the source code to understand the registration pattern."
          },
          {
            "id": 2,
            "title": "Create agent command file structure",
            "description": "Create the packages/cli/src/commands/agent.ts file with the basic Commander.js command structure for the agent command and its subcommands.",
            "dependencies": ["46.1"],
            "details": "Set up the agent.ts file with Commander.js program instance, define the main 'agent' command, and create the subcommand structure for 'start' and 'stop' with proper argument handling for <agent_type>.",
            "status": "done",
            "testStrategy": "Verify the file is created with proper TypeScript imports and basic command structure that can be imported without errors."
          },
          {
            "id": 3,
            "title": "Implement start and stop subcommand definitions",
            "description": "Define the 'start' and 'stop' subcommands in agent.ts with proper argument parsing, validation, and placeholder command handlers.",
            "dependencies": ["46.2"],
            "details": "Create 'start <agent_type>' and 'stop <agent_type>' subcommands with argument validation to ensure 'browser' is the accepted agent type. Add descriptive help text and error handling for invalid agent types.",
            "status": "done",
            "testStrategy": "Test argument parsing by running the commands with various inputs and verify proper error messages are shown for invalid agent types."
          },
          {
            "id": 4,
            "title": "Register agent command in main CLI index",
            "description": "Add the agent command to the main CLI command registration file to make it discoverable through the pk CLI.",
            "dependencies": ["46.2", "46.3"],
            "details": "Import the agent command from agent.ts into packages/cli/src/commands/index.ts and add it to the command registration/export structure following the existing pattern used by other commands.",
            "status": "done",
            "testStrategy": "Run 'pk --help' to verify the agent command appears in the available commands list."
          },
          {
            "id": 5,
            "title": "Add comprehensive help text and command validation",
            "description": "Implement detailed help text for the agent command and its subcommands, and add proper command validation and error handling.",
            "dependencies": ["46.3", "46.4"],
            "details": "Add descriptive help text explaining the purpose of the agent command, its subcommands, and the browser agent type. Include usage examples and ensure error messages are clear and actionable.",
            "status": "done",
            "testStrategy": "Run 'pk agent --help' to verify subcommands are listed with proper descriptions. Execute 'pk agent start browser' and 'pk agent stop browser' to confirm commands are recognized and provide appropriate feedback even without full implementation."
          }
        ]
      },
      {
        "id": 47,
        "title": "Implement `pk config browser` Command for Chrome Path Setup",
        "description": "Create the `pk config browser` command to allow users to configure the path to their Chrome user data directory.",
        "details": "Implement an interactive command using a library like `inquirer`. The command should attempt to automatically detect the default Chrome user data directory for the user's operating system (Windows, macOS, Linux). If detection fails or the user prefers, it must provide an option for manual path entry.",
        "testStrategy": "Execute `pk config browser` on different operating systems to test auto-detection. Test the manual entry flow. Verify that the command handles user cancellation (e.g., Ctrl+C) gracefully. Ensure the command interface is clear and user-friendly.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement OS-specific Chrome path detection logic",
            "description": "Create functions to automatically detect the default Chrome user data directory for Windows, macOS, and Linux operating systems using platform-specific path conventions.",
            "dependencies": [],
            "details": "Implement detection functions for each OS: Windows (%LOCALAPPDATA%\\Google\\Chrome\\User Data), macOS (~/Library/Application Support/Google/Chrome), and Linux (~/.config/google-chrome). Handle cases where Chrome is not installed or paths don't exist. Use Node.js fs module to verify path existence.",
            "status": "cancelled",
            "testStrategy": "Test detection on each supported OS. Verify correct paths are returned when Chrome is installed. Test behavior when Chrome is not installed or paths are missing."
          },
          {
            "id": 2,
            "title": "Set up inquirer interactive prompt interface",
            "description": "Configure inquirer to present users with auto-detected Chrome path and options for manual entry or confirmation.",
            "dependencies": ["47.1"],
            "details": "Use inquirer to create an interactive prompt that shows the auto-detected Chrome path (if found) and asks for confirmation. Provide options to use detected path, enter custom path, or cancel. Include input validation for custom paths to ensure they exist and are accessible.",
            "status": "done",
            "testStrategy": "Test prompt flow with auto-detected paths. Test manual path entry with valid and invalid paths. Test cancellation behavior (Ctrl+C). Verify input validation works correctly."
          },
          {
            "id": 3,
            "title": "Integrate with existing config system for path storage",
            "description": "Connect the browser command to the existing configuration system to persist the Chrome user data directory path.",
            "dependencies": ["47.2"],
            "details": "Use the existing config infrastructure from packages/cli/src/config/config.ts to store the browser path setting. Add a new config key for browser path storage. Ensure the path is saved securely and can be retrieved by other parts of the system.",
            "status": "done",
            "testStrategy": "Verify that configured paths are properly stored and retrievable. Test config persistence across CLI sessions. Ensure integration with existing config commands doesn't break."
          },
          {
            "id": 4,
            "title": "Add browser subcommand to CLI command structure",
            "description": "Create the 'browser' subcommand under the existing 'config' command in the CLI architecture.",
            "dependencies": ["47.3"],
            "details": "Add the browser subcommand to packages/cli/src/commands/config.ts or create a separate config/browser.ts file. Ensure proper command registration and help text. Follow existing CLI patterns and conventions used in other config subcommands.",
            "status": "done",
            "testStrategy": "Test that 'pk config browser' is recognized as a valid command. Verify help text is displayed correctly. Test command shows up in 'pk config --help' output."
          },
          {
            "id": 5,
            "title": "Implement comprehensive error handling and user feedback",
            "description": "Add robust error handling for all failure scenarios including permission issues, invalid paths, and system-specific edge cases.",
            "dependencies": ["47.1", "47.2", "47.3", "47.4"],
            "details": "Handle scenarios like: insufficient permissions to access Chrome directory, Chrome not installed, custom path doesn't exist, path is not a directory, and system-specific access issues. Provide clear, actionable error messages for each case. Ensure graceful handling of user cancellation.",
            "status": "done",
            "testStrategy": "Test with insufficient permissions, non-existent paths, files instead of directories, and various edge cases. Verify error messages are helpful and non-technical. Test cancellation handling."
          }
        ]
      },
      {
        "id": 48,
        "title": "Integrate Browser Configuration with `.mcp.json`",
        "description": "Connect the `pk config browser` command to the `.mcp.json` configuration file, enabling it to read and write the browser user data directory path.",
        "details": "The logic for `pk config browser` should read the `.mcp.json` file. Upon successful path input from the user, it must validate that the directory path exists on the filesystem. If valid, it will update the `BROWSER_USE_USER_DATA_DIR` key within the `browser-use` server configuration object and save the file. Handle cases where the file or keys do not yet exist.",
        "testStrategy": "Check the state of `.mcp.json` before running the command. Run `pk config browser`, provide a valid path, and confirm that `.mcp.json` is correctly updated. Test again by providing an invalid/non-existent path and verify that the command shows an error and does not update the configuration file.",
        "priority": "high",
        "dependencies": [47],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Update `start-browser-agent.sh` to Use Dynamic Configuration",
        "description": "Modify the `start-browser-agent.sh` script to dynamically read the Chrome user data directory path from `.mcp.json` instead of using a hardcoded placeholder.",
        "details": "The script should use a command-line JSON processor like `jq` to parse `.mcp.json` and extract the `BROWSER_USE_USER_DATA_DIR` value. This value should then be exported as an environment variable that is used when executing the `uvx browser-use --mcp` command. Add basic error handling to the script for cases where `jq` is not installed or the config file is missing.",
        "testStrategy": "Manually execute the modified `start-browser-agent.sh` script in a terminal. Verify that it correctly reads the path from a sample `.mcp.json`. Use `echo` statements or logging to confirm that the correct environment variable is set before the `uvx` command is called.",
        "priority": "medium",
        "dependencies": [48],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Implement Browser Agent Process Lifecycle Management",
        "description": "Develop the core logic in `agent.ts` for the `pk agent start browser` and `pk agent stop browser` commands to manage the browser-use MCP server process.",
        "status": "done",
        "dependencies": [46, 49],
        "priority": "high",
        "details": "**Context:**\nThis task builds on completed work for CLI registration (46), browser config (47), .mcp.json integration (48), and the dynamic agent script (49). The current `agent.ts` contains placeholder start/stop functions that require full implementation.\n\n**Key Files & Constants:**\n- Main Logic: `packages/cli/src/commands/agent.ts`\n- Script to Execute: `scripts/start-browser-agent.sh`\n- Configuration Source: `.mcp.json`\n- PID File Path: `path.join('.taskmaster', 'browser-agent.pid')` (constant: `BROWSER_AGENT_PID_FILE`)\n\n**Implementation Plan:**\n\n1.  **Enhance `startBrowserAgent()`:**\n    -   Before starting, perform pre-checks: verify `.mcp.json` exists and that no agent process is already running (check PID file).\n    -   Ensure the `.taskmaster` directory exists before attempting to write the PID file.\n    -   Use `child_process.spawn` to run `start-browser-agent.sh` in detached mode. Implement cross-platform compatibility for spawning the script.\n    -   Capture the new process ID (PID), validate it, and write it to the `browser-agent.pid` file.\n    -   Implement robust error handling for spawn failures or PID writing issues.\n\n2.  **Enhance `stopBrowserAgent()`:**\n    -   Read the PID from `browser-agent.pid`.\n    -   Handle stale PID files: if the file exists but the process ID is not running, notify the user and clean up the file.\n    -   Implement a graceful termination sequence: first send `SIGTERM`, wait briefly, and if the process still exists, send `SIGKILL`.\n    -   Add comprehensive error handling for cases where the process is already gone or the PID file is missing.\n    -   Delete the PID file upon successful termination.\n\n3.  **Cross-Platform Logic:**\n    -   For Unix-like systems (Linux, macOS): `spawn('bash', [scriptPath], { detached: true, stdio: 'ignore' })`\n    -   For Windows: `spawn('cmd', ['/c', 'bash', scriptPath], { detached: true, stdio: 'ignore' })`\n    -   Handle potential permission and script execution errors on all platforms.",
        "testStrategy": "Run `pk agent start browser`. Verify that a `uvx` process is running and that the `.taskmaster/browser-agent.pid` file is created with the correct PID. Run `pk agent stop browser`. Verify the process is terminated and the PID file is removed. Test starting and stopping multiple times to check for stability. Also test edge cases like starting an already running agent and stopping a non-existent one.",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "Ensure Windows Compatibility for Agent Scripts and Process Management",
        "description": "Create a Windows-compatible version of the start script and update the Node.js process management logic to be cross-platform.",
        "status": "pending",
        "dependencies": [50],
        "priority": "medium",
        "details": "The Windows batch script (start-browser-agent.bat) has been created and mirrors the bash functionality with PowerShell JSON parsing and findstr fallback. Now need to update agent.ts to use platform detection for script selection and improve Windows process termination using taskkill instead of SIGTERM/SIGKILL.",
        "testStrategy": "On a Windows 10/11 machine, perform the full end-to-end test: run `pk config browser`, then `pk agent start browser`, and finally `pk agent stop browser`. Use Task Manager or `tasklist` to verify the `uvx` process is created and terminated correctly.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Windows batch script",
            "description": "Create start-browser-agent.bat that mirrors bash functionality",
            "status": "done",
            "dependencies": [],
            "details": "Windows batch script created with PowerShell JSON parsing and findstr fallback, handles all error cases and environment variable setting",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Update agent.ts spawn logic for Windows",
            "description": "Modify spawn logic in packages/cli/src/commands/agent.ts lines 75-78 to detect Windows platform and use .bat script",
            "status": "done",
            "dependencies": [],
            "details": "Use process.platform === 'win32' to detect OS and execute appropriate script (.bat vs .sh)",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Improve Windows process termination",
            "description": "Update stopBrowserAgent() function to use taskkill on Windows instead of SIGTERM/SIGKILL",
            "status": "done",
            "dependencies": [],
            "details": "Implement Windows-specific process termination using taskkill command for better reliability",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Test complete Windows implementation",
            "description": "Perform end-to-end testing on Windows system",
            "status": "pending",
            "dependencies": [],
            "details": "Test full workflow: pk config browser -> pk agent start browser -> pk agent stop browser on Windows 10/11",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Run build validation",
            "description": "Execute npm run preflight to validate all changes",
            "status": "pending",
            "dependencies": [],
            "details": "Ensure all code changes pass linting, type checking, and tests",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 52,
        "title": "Verify MCP Integration and Browser Tool Discovery",
        "description": "Conduct end-to-end testing to ensure the browser-use MCP server integrates correctly and its tools are discoverable by the AI agent during a chat session.",
        "details": "This task focuses on verifying the connection between the core CLI and the background agent process. The existing `mcp-client.ts` should handle the connection and tool prefixing. The primary goal is to confirm that when the agent is running, the client successfully connects on the configured port and registers the browser tools (e.g., `browser.navigate`).",
        "testStrategy": "1. Start the agent with `pk agent start browser`. 2. Initiate an AI session with `pk chat`. 3. Check the CLI debug logs for messages indicating a successful connection to the browser-use MCP server and registration of tools. 4. Issue a command to the AI like 'navigate to piece.work' and verify it executes correctly.",
        "priority": "high",
        "dependencies": [50],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "Implement Comprehensive Error Handling and User Feedback",
        "description": "Improve the user experience by adding robust error handling and clear, actionable feedback across all new commands and features.",
        "details": "Review all new code paths and implement checks for potential failures. This includes: `browser-use` package not being installed, configured Chrome path not existing, agent already running when `start` is called, agent not running when `stop` is called, stale PID file, and MCP port conflicts. For each case, provide a clear, user-friendly error message and exit gracefully.",
        "testStrategy": "Systematically trigger each error condition. For example: uninstall `browser-use`, run `pk agent start browser`. Configure a bad path, run `start`. Run `start` twice. Manually kill the agent process, then run `stop`. Verify that in each case, the CLI outputs a helpful error message and does not crash.",
        "priority": "medium",
        "dependencies": [50, 51, 52],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-26T18:17:50.719Z",
      "updated": "2025-07-28T04:24:49.839Z",
      "description": "Tasks for master context"
    }
  }
}
